% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/anova.R
\name{modelMeans}
\alias{modelMeans}
\alias{modelMeans.default}
\alias{modelMeans.arrayAnova}
\alias{modelMeans.tanova}
\title{Compute adjusted or unadjusted cell means in ANOVA designs}
\usage{
modelMeans(...)

\method{modelMeans}{default}(
  .arraydat,
  factordef,
  bwdat = NULL,
  term = NULL,
  adjusted = FALSE,
  ...
)

\method{modelMeans}{arrayAnova}(model = NULL, term = NULL, adjusted = FALSE, ...)

\method{modelMeans}{tanova}(model = NULL, term = NULL, adjusted = FALSE, ...)
}
\arguments{
\item{...}{not used yet}

\item{.arraydat}{a numeric array with named dimnames containing the EEG (or
other) data. Missing values are not allowed.}

\item{factordef}{a named list of factor definitions, containing the following
elements:
\itemize{
\item{between: }{character vector of between-subject factors (default: NULL)}
\item{within: }{character vector of within-subject factors (default: NULL)}
\item{w_id: }{name of the dimension which identifies the subjects
(default: "id")}
}}

\item{bwdat}{a data.frame which contains the identification codes
(factordef$w_id) and all subject-level variables (usually factors) listed in
'factordef$between'. Missing values are not allowed.}

\item{term}{a character vector of model terms; a separate array of cell means
is returned for each term. The default is NULL, in which case all terms
(that is, the means corresponding to all main effects and interactions) are
returned. For custom terms, note that interaction terms must be given as
"factorA*factorB" and not as "factorA:factorB".}

\item{adjusted}{a logical value if the cell means should be adjusted for
unbalanced data (default: FALSE). See Details.}

\item{model}{an object returned by \code{\link{arrayAnova}} or
\code{\link{tanova}}}
}
\value{
The function returns a named list of arrays; the names are the model
terms.
}
\description{
\code{modelMeans} is a generic function for computing adjusted or unadjusted
cell means in ANOVA designs.
}
\details{
If 'adjusted' is set to FALSE (the default), \code{modelMeans} fits
separate models for each model term and computes the model-based predictions
for a reference grid which contains the mean and the 1SD value for continuous
covariates, and all levels of the factor variables in the design. If
'adjusted' is set to TRUE, the means are simply the marginal means of the
predicted means of the highest-order interaction term. This is equivalent to
the so-called LS means (least-squares means) in the SAS terminology.
This distinction is only relevant if the design is unbalanced, that is, the
sample sizes in a between-subject design are unequal (note that the input
array may not contain missing values, therefore the within subject part of
the design is always balanced). For such datasets the lower order
interaction or main effect means can substantially differ from the averages
of the corresponding higher-order means if 'adjusted' is FALSE.
}
\section{Methods (by class)}{
\itemize{
\item \code{default}: Default method

\item \code{arrayAnova}: Method for \code{arrayAnova} objects

\item \code{tanova}: Method for \code{tanova} objects
}}

\examples{
# example data
data(erps)
dat_id <- attr(erps, "id") # to get group memberships

# make the dataset unbalanced to illustrate the difference between adjusted
# and unadjusted means
erps <- subsetArray(erps, list(id = 2:20))
dat_id <- dat_id[2:20, ]

# compute the means for the group*stimclass*pairtype interaction and all
# other lower-order terms
fdef <- list(between = "group",
             within = c("stimclass", "pairtype"))
means <- modelMeans(erps, fdef, bwdat = dat_id)

# the same for the least-squares means
means_adj <- modelMeans(erps, fdef, bwdat = dat_id, adjusted = TRUE)

# this is an unbalanced dataset, so the means for the highest order
# interaction are identical, but the marginal means are not
stopifnot(identical(
    TRUE,
    all.equal(means$`group*stimclass*pairtype`,
              means_adj$`group*stimclass*pairtype`))
)
stopifnot(!identical(
    TRUE,
    all.equal(means$`stimclass*pairtype`,
              means_adj$`stimclass*pairtype`))
)

# simple means for the Fz channel at time 200, for identical pairs in the
# "A" stimulus class, separately for the two reading groups
simple_means <- sapply(c("control", "dl"), function(g)
    mean(subsetArray(erps,
                     list(chan = "Fz", time = "200",
                          stimclass = "A", pairtype = "ident",
                          id = dat_id$group == g)))
)
stopifnot(identical(
    TRUE,
    all.equal(means$`group*stimclass*pairtype`["Fz", "200", , "A", "ident"],
              simple_means))
)

# the same ignoring the groups
simple_mean_nogroup <- mean(subsetArray(erps,
                                        list(chan = "Fz", time = "200",
                                        stimclass = "A", pairtype = "ident")))
stopifnot(identical(
    TRUE,
    all.equal(means$`stimclass*pairtype`["Fz", "200", "A", "ident"],
              simple_mean_nogroup))
)
stopifnot(identical(
    TRUE,
    all.equal(means_adj$`stimclass*pairtype`["Fz", "200", "A", "ident"],
              mean(simple_means)))
)

}
