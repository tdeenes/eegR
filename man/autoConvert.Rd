% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/array_transform.R
\name{autoConvert}
\alias{autoConvert}
\title{Convert (coerce) variables according to various schemes}
\usage{
autoConvert(
  dat,
  select = NULL,
  conversion = "ANY",
  rules = convertParams(),
  keep_dim = TRUE
)
}
\arguments{
\item{dat}{an object}

\item{select}{numeric or character indices of the variables or list elements
which sould be converted, if 'dat' is a data.frame or a list, respectively}

\item{conversion}{a character vector referring to the conversion rule
which should be applied for the selected variable/list element. If a single 
value, the same rule is applied for all variables/list elements. The default
is 'ANY', which is handled in a special way (see Details).}

\item{rules}{a list of conversion rules, see \code{\link{convertParams}}.
To save typing, \code{.(key = value)} format is also accepted, and the 
arguments inside the parentheses are forwarded to 
\code{\link{convertParams}}.}

\item{keep_dim}{a logical value whether the dimensions and dimension names
should be retained after the conversion (default: TRUE)}
}
\description{
\code{autoConvert} converts the variables which meet specific conditions 
on the basis of pre-defined conversion rules.
}
\details{
If 'conversion' is 'ANY' (the default), the 'IF' conditions in 
the rule definitions in 'rules' are tested and for the first successful test,
the given rule is selected. To avoid these sequential tests, provide the 
name of the rule definition explicitly in 'conversion'.
The rule definitions can be extended by arbitrary rules; it is suggested to
prepare the rules by calling \code{\link{convertParams}} in advance (see
Examples).
}
\examples{
# create an example list with various variable types
x <- list(A = c(1L, 0L, 0L),  # integer, but could be simplified to logical 
          B = matrix(c(1, 3, 2, 1), 2, 2), # double, but could be integer  
          C = c("1.2", "1", "0.92"),   # character, which could be double
          D = factor(c("a", "b", "a"), levels = c("b", "a")) 
                 # factor, which might be converted to character
          )
( x_simplified <- autoConvert(x) )
\dontshow{
stopifnot(is.logical(x_simplified$A))
stopifnot(is.integer(x_simplified$B))
stopifnot(identical(dim(x$B), dim(x_simplified$B)))
stopifnot(is.double(x_simplified$C))
stopifnot(is.character(x_simplified$D))
}

# a simple way to convert only those list elements which are factors
autoConvert(x, conversion = "factor")

# suppose you do not want to convert characters at all
rules <- convertParams()
new_rules <- rules[setdiff(names(rules), "character")]
( x_simplified2 <- autoConvert(x, rules = new_rules) )
\dontshow{
stopifnot(identical(x$C, x_simplified2$C))
}

# you can also convert an atomic object
autoConvert(c("1.12", "3.4"))
\dontshow{
stopifnot(identical(autoConvert(c("1.12", "3.4")),
                    as.numeric(c("1.12", "3.4"))))
}
}
