% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/array_general.R
\name{selectValues}
\alias{selectValues}
\title{Select values from a vector, matrix or array}
\usage{
selectValues(
  dat,
  condition,
  return_index = TRUE,
  dim_labels = NULL,
  value_label = "value",
  auto_convert = TRUE
)
}
\arguments{
\item{dat}{an atomic object}

\item{condition}{an IsFunction (see Details)}

\item{return_index}{a logical value whether the indices of the selected
values should be returned (default: TRUE)}

\item{dim_labels}{a character vector; the name of the dimensions in the
returned data.frame. If NULL (the default), the labels are extracted from
the names of the dimnames attribute of the input data. If a single string, 
the dimension numbers are appended after it.}

\item{value_label}{the name of the column in the returned data.frame which
represent the values (default: "value")}

\item{auto_convert}{a logical value whether automatic conversion of
dimension names (i.e., characters to numeric (if possible) or to factors)
should be performed (default: TRUE). Set to FALSE and call 
\code{\link{autoConvert}} directly on the returned data frame if you need
more control.}
}
\value{
This function returns a data frame with 'dim_labels' columns 
containing the combination of the dimension levels where the selected values
were found and an extra column of the selected values themselves.\cr
If 'return_index' is TRUE, the numeric matrix of indices is returned as an
additional attribute ('index'). This comes handy if one wants to select data
points in the same positions from an other object having the same shape as
'dat'.
}
\description{
\code{selectValues} returns values (and their indices) of a vector, matrix,
or array which meet the user-defined conditions.
}
\details{
\code{selectValues} builds upon the \code{\link[eegR]{is}} 
family of functions. The standard workflow is to define (and possibly 
combine) the conditions, and then feed the data into \code{selectValues}
with the given condiiton object.
}
\examples{
#
# A complex use-case: find peaks of curves meeting compex rules
#
# load example data
data(erps)

# analyze only the three midline electrodes and use the
# grand averages, for simplicity
erps <- subsetArray(erps, chan = c("Fz", "Cz", "Pz"))
avgs <- avgDims(erps, "id")

# find the most negative peak at Fz between 80 and 200 ms, and also select
# the corresponding time points on the two other channels
cond <- isMinimum(options. = list(along_dim = "time"),
                  subset. = list(time = isBetween(80, 200)),
                  expand. = list(chan = "Fz")) &
        isNegative(expand. = list(chan = "Fz"))

# find the peaks
results <- selectValues(avgs, cond)

#
# plot the grand averages, and add points to the curves where a peak was found;
# note that the peaks are based on the Fz channel
#
library(ggplot2)
ggplot(transformArray(value ~ ., avgs), 
       aes(x = time, y = value, col = chan)) +
    geom_line() + facet_grid(stimclass ~ pairtype) + 
    geom_point(data = results, size = 3) + 
    theme_bw()
}
\seealso{
\code{\link[eegR]{is}}
}
\concept{find peaks}
