% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/array_transform.R
\name{expandInto}
\alias{expandInto}
\title{Expand array}
\usage{
expandInto(dat, new_dat, expand_levels = NULL, safe_mode = TRUE)
}
\arguments{
\item{dat}{an array}

\item{new_dat}{an array to expand 'dat' into}

\item{expand_levels}{a list of vectors which define the expanding scheme
for each dimension of 'dat' or a named list of vectors where the names refer
to selected dimensions in 'dat' (in this case 'dat' must have named
dimnames). The length of each vector in 'expand_levels' must match the
corresponding dimension size in 'new_dat'. The vectors must contain either
numeric or character indices of the levels of the given dimension in 'dat'.}

\item{safe_mode}{a logical value whether the expansion of non-singleton
dimensions is not allowed if the corresponding vectors in 'expand_levels' are
not provided (default: TRUE). If 'safe_mode' is TRUE, and both 'dat' and
'new_dat' has dimension names, non-expanded dimensions are checked if the
order of levels should be adjusted for the given dimension. See Examples.}
}
\description{
\code{expandInto} expands an array to a larger array (either to an array
with more dimensions or an array with longer dimensions or both).
}
\examples{
# load example data
data(erps)

# -----
# solve the following task: find all data points for which the amplitudes
# in the "Fz" channel are negative, and return TRUE for all corresponding
# data points in the other channels as well
# -----

# subset the data and return TRUE if the values are negative
x_Fz <- subsetArray(erps, chan = "Fz") < 0
str(x_Fz)

# expand this array into the original array
result <- expandInto(x_Fz, erps)
str(result)

# check on a random channel that the results are really fine
x_Cz <- subsetArray(result, chan = "Cz")
# -->
# all TRUEs in x_Fz are also TRUE in x_Cz, and vica versa
( tab <- table(x_Fz, x_Cz) )
stopifnot(identical(sum(diag(tab)), length(x_Fz)))

# -----
# the function is clever enough to reorder the levels for those
# dimensions as well, which should not be expanded, but the order
# of levels is different in 'new_dat'
# -----
# reorder the 'stimclass' dimension in the original ERP array
erps2 <- subsetArray(erps, stimclass = c("C", "B", "A"))

# expand x_Fz again
result2 <- expandInto(x_Fz, erps2)

# turn 'safe_mode' off
result2_notsafe <- expandInto(x_Fz, erps2, safe_mode = FALSE)

# check the results -> result2 is fine
x_Cz_2 <- subsetArray(result2,
                      chan = "Cz",
                      stimclass = c("A", "B", "C"))
( tab <- table(x_Fz, x_Cz_2) )
stopifnot(identical(sum(diag(tab)), length(x_Fz)))

# check the results -> result2_notsafe is wrong
x_Cz_2w <- subsetArray(result2_notsafe,
                       chan = "Cz",
                       stimclass = c("A", "B", "C"))
( tab <- table(x_Fz, x_Cz_2w) )
stopifnot(!identical(sum(diag(tab)), length(x_Fz)))

# -----
# the safest way is to provide 'expand_levels' explicitly for all
# dimensions where the order or number of levels do not match;
# using this argument it is also possible to copy the values of a given
# level to an other one
# -----
# suppose we want stimclass C to be copied from stimclass B while expanding
# to all channels (on the original ERP array)
result <- expandInto(x_Fz, erps,
                     expand_levels = list(stimclass = c("A", "B", "B")))

# check the results
x_Cz_B <- subsetArray(result,
                      chan = "Cz",
                      stimclass = "B")
x_Cz_C <- subsetArray(result,
                      chan = "Cz",
                      stimclass = "C")
# --> they are identical:
stopifnot(identical(x_Cz_B, x_Cz_C))
# --> compared to the results on Fz, stimclass B remained the same:
x_Fz_B <- subsetArray(x_Fz, stimclass = "B")
( tab <- table(x_Fz_B, x_Cz_B) )
stopifnot(identical(sum(diag(tab)), length(x_Fz_B)))
}

