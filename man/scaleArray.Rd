% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/array_general.R
\name{scaleArray}
\alias{scaleArray}
\title{Scale array across arbitrary dimension(s)}
\usage{
scaleArray(
  dat,
  by_dims = NULL,
  along_dims = NULL,
  center = TRUE,
  scale = TRUE,
  base_subset = NULL,
  center_subset = NULL,
  scale_subset = NULL,
  keep_dimorder = TRUE
)
}
\arguments{
\item{dat}{numeric matrix or array}

\item{by_dims, along_dims}{integer or character vector referring to the
dimension(s) of dat across/along which centering/scaling should occur. See
Details.}

\item{center}{logical value if means should be subtracted (default: TRUE)}

\item{scale}{logical value if scaling should occur (default: TRUE)}

\item{base_subset}{argument passed to \code{\link{subsetArray}} before
computing the mean and/or the scale}

\item{center_subset}{the same as base_subset but only applies for the
centering step}

\item{scale_subset}{the same as base_subset but only applies for the
scaling step}

\item{keep_dimorder}{logical value; if TRUE (default), the order of the
dimensions is kept intact, otherwise the channel dimension will be
the first dimension in the resulting matrix or array}
}
\value{
A numeric matrix or array of the same size as the input object
}
\description{
\code{scaleArray} centers and possibly scales the dimensions of an array
across the dimension(s) chosen by the user
}
\details{
\code{scaleArray} is theoretically similar to \code{\link{scale}},
and can be conceived of as if one merges the \code{by_dims} dimensions and
also the \code{along_dims} dimensions of an array, and calls \code{scale}
on the resulting matrix. Thus, the arguments \code{by_dims} and
\code{along_dims} are redundant: use whatever is more convenient in the
given use case (\code{by_dims} defines the rows, \code{along_dims} the
columns).
}
\examples{
# example dataset
data(erps)

# center and scale the data to normalize the subjects (coded with id in the
# array), i.e. all subjects should have mean = 0 and SD = 1
scaled_erps <- scaleArray(erps, along_dims = "id")
means <- apply(scaled_erps, "id", mean)
sds <- apply(scaled_erps, "id", sd)
stopifnot(all.equal(unname(means), rep(0, length(means))))
stopifnot(all.equal(unname(sds), rep(1, length(means))))

# you might want to normalize each subject in each experimental condition
# based only on the pre-stimulus activity
prestim <- as.numeric(dimnames(erps)$time) < 0
base <- list(time = prestim)
scaled_erps <- scaleArray(erps, by_dims = c("chan", "time"),
                          base_subset = base)
means <- apply(subsetArray(scaled_erps, base),
               c("stimclass", "pairtype", "id"),
               mean)
sds <- apply(subsetArray(scaled_erps, base),
             c("stimclass", "pairtype", "id"),
             sd)
stopifnot(all.equal(as.vector(means), rep(0, length(means))))
stopifnot(all.equal(as.vector(sds), rep(1, length(sds))))
}
